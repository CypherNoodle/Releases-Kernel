name: Kernel Debian-Compatible (PGO + BOLT + AutoFDO Incremental, Ultra-Fast, OOM-safe)

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

env:
  CCACHE_DIR: ${{ github.workspace }}/.ccache
  SCCACHE_DIR: ${{ github.workspace }}/.sccache

jobs:

# ------------------------------
# 0) Configuración inicial (Setup)
# ------------------------------
  setup:
    runs-on: ubuntu-latest
    outputs:
      parallel: ${{ steps.calc-parallel.outputs.parallel }}
      maxqemu: ${{ steps.calc-parallel.outputs.maxqemu }}
      boltthreads: ${{ steps.calc-parallel.outputs.boltthreads }}
      xzthreads: ${{ steps.calc-parallel.outputs.xzthreads }}
    steps:
      - name: Checkout kernel source
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Setup environment directories
        run: mkdir -p $CCACHE_DIR $SCCACHE_DIR profdata profdata2

      # Configuración de SWAP para evitar errores OOM (Out Of Memory)
      - name: Setup dynamic swap
        id: swap
        run: |
          MEM_AVAIL=$(free -m | awk '/^Mem:/ {print $7}')
          SWAPFILE=/swapfile
          if [ "$MEM_AVAIL" -lt 4000 ]; then
              sudo fallocate -l 4096M $SWAPFILE
              sudo chmod 600 $SWAPFILE
              sudo mkswap $SWAPFILE
              sudo swapon $SWAPFILE
              echo "swapfile=$SWAPFILE" >> $GITHUB_OUTPUT
          else
              echo "swapfile=none" >> $GITHUB_OUTPUT
          fi

      # Cálculo de hilos para no saturar la CPU del runner
      - name: Calculate safe parallelism & threads
        id: calc-parallel
        run: |
          MEM=$(free -m | awk '/^Mem:/ {print $2}')
          # Regla conservadora: 1 hilo por cada 1.5GB de RAM para compilación pesada con LTO
          PARALLEL=$(( MEM / 1500 ))
          PARALLEL=$(( PARALLEL < 1 ? 1 : PARALLEL ))
          
          # QEMU consume mucha RAM, limitamos instancias
          MAX_QEMU=$(( MEM / 1024 ))
          MAX_QEMU=$(( MAX_QEMU < 1 ? 1 : MAX_QEMU ))
          MAX_QEMU=$(( MAX_QEMU > 4 ? 4 : MAX_QEMU ))
          
          BOLT_THREADS=$(( PARALLEL / 2 ))
          BOLT_THREADS=$(( BOLT_THREADS < 1 ? 1 : BOLT_THREADS ))
          XZ_THREADS=$(( PARALLEL / 2 ))
          XZ_THREADS=$(( XZ_THREADS < 1 ? 1 : XZ_THREADS ))
          
          echo "parallel=$PARALLEL" >> $GITHUB_OUTPUT
          echo "maxqemu=$MAX_QEMU" >> $GITHUB_OUTPUT
          echo "boltthreads=$BOLT_THREADS" >> $GITHUB_OUTPUT
          echo "xzthreads=$XZ_THREADS" >> $GITHUB_OUTPUT

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}

# ------------------------------
# 1) Build incremental base
# Este paso fallaba al subir el artifact. Se ha corregido renombrando .config
# ------------------------------
  build-incremental:
    needs: setup
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
    steps:
      - name: Checkout kernel source (Build)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Install dependencies (incl. gelf.h fix)
        run: |
          set -euo pipefail
          wget https://apt.llvm.org/llvm.sh
          chmod +x llvm.sh
          sudo ./llvm.sh 19
          sudo apt update
          sudo apt install -y build-essential bc bison flex libssl-dev libelf-dev libdw-dev \
          libncurses-dev libncurses5-dev fakeroot dpkg-dev debhelper dwarves zstd git \
          qemu-system-x86 qemu-kvm ccache sccache linux-tools-common linux-tools-generic \
          linux-tools-$(uname -r) zlib1g-dev xz-utils rsync

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-

      - name: Kernel configuration (Fix LTO Duplication)
        working-directory: kernel-src
        run: |
          set -euo pipefail
          
          # 1. Generar configuración base si no existe
          if [ ! -f .config ]; then
            echo "--- .config no encontrado, generando defconfig ---"
            make defconfig
          fi
          
          # 2. Limpieza y activación de LTO (ThinLTO para velocidad)
          sed -i '/CONFIG_LTO_CLANG/d' .config
          sed -i '/CONFIG_THINLTO/d' .config
          
          echo "CONFIG_LTO_CLANG=y" >> .config
          echo "CONFIG_THINLTO=y" >> .config
          
          # 3. FIX CRÍTICO: Quitamos "|| true". Si esto falla, queremos que el build pare aquí.
          echo "--- Aplicando olddefconfig ---"
          make olddefconfig

      - name: Incremental compile baseline kernel
        working-directory: kernel-src
        run: |
          set -euo pipefail
          export CC="sccache clang-19"
          export HOSTCC="ccache clang-19"
          export HOSTCXX="ccache clang++-19"
          export LD=lld
          make -j$PARALLEL vmlinux bzImage modules | tee baseline_incremental.log
          
          # FIX CRÍTICO: Copiamos .config (oculto) a kconfig (visible)
          # Esto asegura que el upload-artifact NO falle.
          cp .config kconfig

      - name: Upload vmlinux baseline
        uses: actions/upload-artifact@v4
        with:
          name: vmlinux-build1
          path: |
            kernel-src/vmlinux
            kernel-src/arch/x86/boot/bzImage

      - name: Upload kernel config
        uses: actions/upload-artifact@v4
        with:
          name: kernel-config
          # Subimos el archivo visible
          path: kernel-src/kconfig

# ------------------------------
# 2) Primer round de PGO + AutoFDO
# Aquí fallaba la descarga. Ahora renombramos kconfig -> .config
# ------------------------------
  pgo-auto:
    needs: build-incremental
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      MAXQEMU: ${{ needs.setup.outputs.maxqemu }}
    steps:
      - name: Checkout kernel source (PGO 1)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Download kernel configuration
        uses: actions/download-artifact@v4
        with:
          name: kernel-config
          path: kernel-src/

      # FIX CRÍTICO: Restauramos el nombre original para que make lo reconozca
      - name: Restore config file
        working-directory: kernel-src
        run: mv kconfig .config

      - name: Download baseline vmlinux
        uses: actions/download-artifact@v4
        with:
          name: vmlinux-build1
          path: kernel-src/

      - name: Restore bzImage location
        working-directory: kernel-src
        run: |
            mkdir -p arch/x86/boot
            find . -name bzImage -exec cp {} arch/x86/boot/bzImage \;

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-

      - name: Collect PGO profiles (round 1)
        working-directory: kernel-src
        run: |
          mkdir -p profdata
          for i in $(seq 1 $MAXQEMU); do
            (
              echo "QEMU instance $i (round 1)"
              # Creamos discos temporales para arrancar QEMU
              dd if=/dev/zero of=disk$i.img bs=1M count=256
              mkfs.ext4 disk$i.img
              # Grabamos perfiles con perf
              sudo perf record -o profdata/perf$i.data -e cycles:u \
                qemu-system-x86_64 -kernel arch/x86/boot/bzImage \
                -append "console=ttyS0" -drive file=disk$i.img,format=raw \
                -nographic -m 1024M -monitor none &
              QEMU_PID=$!
              sleep 10
              sudo kill $QEMU_PID || true
              perf script > profdata/perf$i.out || true
              rm -f disk$i.img
            ) &
          done
          wait
          # Fusionamos los perfiles raw en un formato legible por Clang
          if compgen -G "profdata/*.profraw" > /dev/null; then
            llvm-profdata-19 merge -o profdata/kernel.profdata profdata/*.profraw
          fi

      - name: Upload profdata
        uses: actions/upload-artifact@v4
        with:
          name: profdata
          path: kernel-src/profdata

# ------------------------------
# 3) Build final con PGO round 1 + BOLT
# ------------------------------
  build-final-auto:
    needs:
      - build-incremental
      - pgo-auto
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      BOLTTHREADS: ${{ needs.setup.outputs.boltthreads }}
    steps:
      - name: Checkout kernel source (Build Final 1)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Download kernel configuration
        uses: actions/download-artifact@v4
        with:
          name: kernel-config
          path: kernel-src/

      # FIX CRÍTICO: Restauramos configuración
      - name: Restore config file
        working-directory: kernel-src
        run: mv kconfig .config

      - name: Download baseline artifacts
        uses: actions/download-artifact@v4
        with:
          name: vmlinux-build1
          path: kernel-src/

      - uses: actions/download-artifact@v4
        with:
          name: profdata
          path: kernel-src/profdata
        
      - name: Install dependencies
        run: |
          set -euo pipefail
          wget https://apt.llvm.org/llvm.sh
          chmod +x llvm.sh
          sudo ./llvm.sh 19
          sudo apt update
          sudo apt install -y build-essential bc bison flex libssl-dev libelf-dev libdw-dev \
          libncurses-dev libncurses5-dev fakeroot dpkg-dev debhelper dwarves zstd git \
          qemu-system-x86 qemu-kvm ccache sccache linux-tools-common linux-tools-generic \
          linux-tools-$(uname -r) zlib1g-dev xz-utils rsync

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-
        
      - name: Update kernel configuration
        working-directory: kernel-src
        run: |
          make olddefconfig || true

      - name: Final incremental build with PGO round 1 + BOLT + AutoFDO
        working-directory: kernel-src
        run: |
          PROFILE=profdata/kernel.profdata
          if [ -f "$PROFILE" ]; then
            export CFLAGS_KERNEL="-flto=thin -fprofile-use=$PROFILE"
            export LDFLAGS_vmlinux="-flto -fuse-ld=lld -fprofile-use=$PROFILE"
          fi
          make -j$PARALLEL vmlinux bzImage modules | tee final_auto.log
          
          # BOLT Optimization
          cat profdata/perf*.out 2>/dev/null > profdata/perf_all.out || true
          if [ -s profdata/perf_all.out ]; then
              echo "Aplicando optimizaciones BOLT..."
              llvm-bolt-19 vmlinux -o vmlinux.bolt \
                -reorder-blocks=ext-tsp \
                -reorder-functions=hfsort \
                -split-functions \
                -icf=1 \
                -dyno-trace=profdata/perf_all.out \
                -threads=$BOLTTHREADS | tee bolt.log
              
              # Si BOLT tuvo éxito, reemplazamos el vmlinux original
              if [ -f vmlinux.bolt ] && [ -s vmlinux.bolt ]; then
                mv vmlinux.bolt vmlinux
              fi
          fi

      - name: Upload vmlinux round 1
        uses: actions/upload-artifact@v4
        with:
          name: vmlinux-build2
          path: |
            kernel-src/vmlinux
            kernel-src/arch/x86/boot/bzImage

# ------------------------------
# 4) Segundo round de PGO + AutoFDO
# ------------------------------
  pgo-auto-2:
    needs: build-final-auto
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      MAXQEMU: ${{ needs.setup.outputs.maxqemu }}
    steps:
      - name: Checkout kernel source (PGO 2)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Download kernel configuration
        uses: actions/download-artifact@v4
        with:
          name: kernel-config
          path: kernel-src/

      # FIX CRÍTICO: Restauramos configuración
      - name: Restore config file
        working-directory: kernel-src
        run: mv kconfig .config

      - name: Download previous vmlinux
        uses: actions/download-artifact@v4
        with:
          name: vmlinux-build2
          path: kernel-src/
    
      - name: Restore bzImage location
        working-directory: kernel-src
        run: |
            mkdir -p arch/x86/boot
            find . -name bzImage -exec cp {} arch/x86/boot/bzImage \;

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-

      - name: Collect PGO profiles (round 2)
        working-directory: kernel-src
        run: |
          mkdir -p profdata2
          for i in $(seq 1 $MAXQEMU); do
            (
              echo "QEMU instance $i (round 2)"
              dd if=/dev/zero of=disk2_$i.img bs=1M count=256
              mkfs.ext4 disk2_$i.img
              sudo perf record -o profdata2/perf$i.data -e cycles:u \
                qemu-system-x86_64 -kernel arch/x86/boot/bzImage \
                -append "console=ttyS0" -drive file=disk2_$i.img,format=raw \
                -nographic -m 1024M -monitor none &
              QEMU_PID=$!
              sleep 10
              sudo kill $QEMU_PID || true
              perf script > profdata2/perf$i.out || true
              rm -f disk2_$i.img
            ) &
          done
          wait
          if compgen -G "profdata2/*.profraw" > /dev/null; then
            llvm-profdata-19 merge -o profdata2/kernel.profdata profdata2/*.profraw
          fi

      - name: Upload profdata2
        uses: actions/upload-artifact@v4
        with:
          name: profdata2
          path: kernel-src/profdata2

# ------------------------------
# 5) Build final y Release
# ------------------------------
  build-final-auto-2:
    needs:
      - build-final-auto
      - pgo-auto-2
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      BOLTTHREADS: ${{ needs.setup.outputs.boltthreads }}
      XZTHREADS: ${{ needs.setup.outputs.xzthreads }}
    steps:
      - name: Checkout kernel source (Final Release)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Download kernel configuration
        uses: actions/download-artifact@v4
        with:
          name: kernel-config
          path: kernel-src/

      # FIX CRÍTICO: Restauramos configuración
      - name: Restore config file
        working-directory: kernel-src
        run: mv kconfig .config

      - name: Download baseline artifacts
        uses: actions/download-artifact@v4
        with:
          name: vmlinux-build1
          path: kernel-src/

      - uses: actions/download-artifact@v4
        with:
          name: profdata2
          path: kernel-src/profdata2
        
      - name: Install dependencies
        run: |
          set -euo pipefail
          wget https://apt.llvm.org/llvm.sh
          chmod +x llvm.sh
          sudo ./llvm.sh 19
          sudo apt update
          sudo apt install -y build-essential bc bison flex libssl-dev libelf-dev libdw-dev \
          libncurses-dev libncurses5-dev fakeroot dpkg-dev debhelper dwarves zstd git \
          qemu-system-x86 qemu-kvm ccache sccache linux-tools-common linux-tools-generic \
          linux-tools-$(uname -r) zlib1g-dev xz-utils rsync

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-
        
      - name: Update kernel configuration for final build
        working-directory: kernel-src
        run: |
          make olddefconfig || true

      - name: Final incremental build with PGO round 2 + BOLT + AutoFDO
        working-directory: kernel-src
        run: |
          PROFILE=profdata2/kernel.profdata
          if [ -f "$PROFILE" ]; then
            export CFLAGS_KERNEL="-flto=thin -fprofile-use=$PROFILE"
            export LDFLAGS_vmlinux="-flto -fuse-ld=lld -fprofile-use=$PROFILE"
          fi
          # Compilamos vmlinux y modulos antes de empaquetar
          make -j$PARALLEL vmlinux modules | tee finalautoround2.log
          
          # Aplicar BOLT Round 2
          cat profdata2/perf*.out 2>/dev/null > profdata2/perf_all.out || true
          if [ -s profdata2/perf_all.out ]; then
              llvm-bolt-19 vmlinux -o vmlinux.bolt \
                -reorder-blocks=ext-tsp \
                -reorder-functions=hfsort \
                -split-functions \
                -icf=1 \
                -dyno-trace=profdata2/perf_all.out \
                -threads=$BOLTTHREADS | tee boltround2.log
              if [ -f vmlinux.bolt ] && [ -s vmlinux.bolt ]; then
                mv vmlinux.bolt vmlinux
              fi
          fi

      - name: Build .deb packages + SHA256
        working-directory: kernel-src
        run: |
          export DEBBUILDOPTIONS="parallel=$PARALLEL"
          rm -rf ../debs2
          mkdir -p ../debs2
          
          # Generamos los paquetes. bindeb-pkg usará el vmlinux existente (optimizado)
          make -j$PARALLEL bindeb-pkg LOCALVERSION="-${{ github.run_number }}-final" | tee debround2.log
          
          cp ../*.deb ../debs2/
          cd ../debs2
          sha256sum *.deb > SHA256SUMS.txt

      - name: Generate CHANGELOG
        working-directory: kernel-src
        run: |
          PREV=$(git describe --tags --abbrev=0 --match "v*" HEAD^ 2>/dev/null || true)
          if [ -n "$PREV" ]; then
            git log --pretty=format:"%h - %s (%an)" "$PREV"..HEAD > ../CHANGELOG.txt
          else
            git log --reverse --max-count=30 --pretty=format:"%h - %s (%an)" > ../CHANGELOG.txt
          fi

      - name: Upload final release artifacts
        uses: softprops/action-gh-release@v1
        with:
          files: |
            debs2/*.deb
            debs2/SHA256SUMS.txt
            ../CHANGELOG.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
