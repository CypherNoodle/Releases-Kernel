name: Kernel Debian-Compatible (PGO + BOLT + AutoFDO Incremental, Ultra-Fast, OOM-safe)

on:
   push:
    tags:
      - 'v*'
   workflow_dispatch:

env:
  CCACHE_DIR: ${{ github.workspace }}/.ccache
  SCCACHE_DIR: ${{ github.workspace }}/.sccache

jobs:

# ------------------------------
# 0) Configuración inicial del runner
# ------------------------------
  setup:
    runs-on: ubuntu-latest
    outputs:
      parallel: ${{ steps.calc-parallel.outputs.parallel }}
      maxqemu: ${{ steps.calc-parallel.outputs.maxqemu }}
      boltthreads: ${{ steps.calc-parallel.outputs.boltthreads }}
      xzthreads: ${{ steps.calc-parallel.outputs.xzthreads }}
    steps:
      - name: Checkout kernel source
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Install dependencies
        run: |
          set -euo pipefail
          wget https://apt.llvm.org/llvm.sh
          chmod +x llvm.sh
          sudo ./llvm.sh 19
          sudo apt update
          sudo apt install -y build-essential bc bison flex libssl-dev libelf-dev libdw-dev \
          libncurses-dev libncurses5-dev fakeroot dpkg-dev debhelper dwarves zstd git \
          qemu-system-x86 qemu-kvm ccache sccache linux-tools-common linux-tools-generic \
          linux-tools-$(uname -r) zlib1g-dev xz-utils rsync
          mkdir -p $CCACHE_DIR $SCCACHE_DIR profdata profdata2

      - name: Setup dynamic swap
        id: swap
        run: |
          MEM_AVAIL=$(free -m | awk '/^Mem:/ {print $7}')
          SWAPFILE=/swapfile
          if [ "$MEM_AVAIL" -lt 4000 ]; then
              sudo fallocate -l 4096M $SWAPFILE
              sudo chmod 600 $SWAPFILE
              sudo mkswap $SWAPFILE
              sudo swapon $SWAPFILE
              echo "swapfile=$SWAPFILE" >> $GITHUB_OUTPUT
          else
              echo "swapfile=none" >> $GITHUB_OUTPUT
          fi

      - name: Calculate safe parallelism & threads
        id: calc-parallel
        run: |
          MEM=$(free -m | awk '/^Mem:/ {print $2}')
          PARALLEL=$(( MEM / 1500 ))
          PARALLEL=$(( PARALLEL < 1 ? 1 : PARALLEL ))
          MAX_QEMU=$(( MEM / 1024 ))
          MAX_QEMU=$(( MAX_QEMU < 1 ? 1 : MAX_QEMU ))
          MAX_QEMU=$(( MAX_QEMU > 4 ? 4 : MAX_QEMU ))
          BOLT_THREADS=$(( PARALLEL / 2 ))
          BOLT_THREADS=$(( BOLT_THREADS < 1 ? 1 : BOLT_THREADS ))
          XZ_THREADS=$(( PARALLEL / 2 ))
          XZ_THREADS=$(( XZ_THREADS < 1 ? 1 : XZ_THREADS ))
          
          echo "parallel=$PARALLEL" >> $GITHUB_OUTPUT
          echo "maxqemu=$MAX_QEMU" >> $GITHUB_OUTPUT
          echo "boltthreads=$BOLT_THREADS" >> $GITHUB_OUTPUT
          echo "xzthreads=$XZ_THREADS" >> $GITHUB_OUTPUT

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}

# ------------------------------
# 1) Build incremental base
# ------------------------------
  build-incremental:
    needs: setup
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
    steps:
      - name: Checkout kernel source (Build)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-

      - name: Kernel configuration
        working-directory: kernel-src
        run: |
          set -euo pipefail
          if [ ! -f .config ]; then
            make defconfig
            echo "CONFIGLTOCLANG=y" >> .config
            echo "CONFIG_THINLTO=y" >> .config
            make olddefconfig
          fi

      - name: Incremental compile baseline kernel
        working-directory: kernel-src
        run: |
          set -euo pipefail
          export CC="sccache clang-19"
          export HOSTCC="ccache clang-19"
          export HOSTCXX="ccache clang++-19"
          export LD=lld
          # Compilamos bzImage también para ahorrar tiempo en el Job 2
          make -j$PARALLEL vmlinux bzImage modules | tee baseline_incremental.log

      - name: Upload vmlinux baseline
        uses: actions/upload-artifact@v4
        with:
          name: vmlinux-build1
          path: |
            kernel-src/vmlinux
            kernel-src/arch/x86/boot/bzImage

      - name: Upload kernel config
        uses: actions/upload-artifact@v4
        with:
          name: kernel-config
          path: kernel-src/.config

# ------------------------------
# 2) Primer round de PGO + AutoFDO
# ------------------------------
  pgo-auto:
    needs: build-incremental
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      MAXQEMU: ${{ needs.setup.outputs.maxqemu }}
    steps:
      - name: Checkout kernel source (PGO 1)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Download kernel configuration
        uses: actions/download-artifact@v4
        with:
          name: kernel-config
          path: kernel-src/

      # Descargamos vmlinux y bzImage del paso anterior
      - name: Download baseline vmlinux
        uses: actions/download-artifact@v4
        with:
          name: vmlinux-build1
          path: kernel-src/

      # Movemos bzImage a su lugar correcto (artifact download no preserva estructura completa a veces)
      - name: Restore bzImage location
        working-directory: kernel-src
        run: |
            mkdir -p arch/x86/boot
            # Si el artifact bajó en la raiz o carpeta equivocada, aseguramos su lugar
            find . -name bzImage -exec cp {} arch/x86/boot/bzImage \;

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-

      - name: Collect PGO profiles (round 1)
        working-directory: kernel-src
        run: |
          mkdir -p profdata
          for i in $(seq 1 $MAXQEMU); do
            (
              echo "QEMU instance $i (round 1)"
              dd if=/dev/zero of=disk$i.img bs=1M count=256
              mkfs.ext4 disk$i.img
              # Usamos el bzImage descargado/restaurado
              sudo perf record -o profdata/perf$i.data -e cycles:u \
                qemu-system-x86_64 -kernel arch/x86/boot/bzImage \
                -append "console=ttyS0" -drive file=disk$i.img,format=raw \
                -nographic -m 1024M -monitor none &
              QEMU_PID=$!
              sleep 10
              sudo kill $QEMU_PID || true
              perf script > profdata/perf$i.out || true
              rm -f disk$i.img
            ) &
          done
          wait
          if compgen -G "profdata/*.profraw" > /dev/null; then
            llvm-profdata-19 merge -o profdata/kernel.profdata profdata/*.profraw
          fi

      - name: Upload profdata
        uses: actions/upload-artifact@v4
        with:
          name: profdata
          path: kernel-src/profdata

# ------------------------------
# 3) Build final con PGO round 1 + BOLT + AutoFDO
# ------------------------------
  build-final-auto:
    needs:
      - build-incremental
      - pgo-auto
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      BOLTTHREADS: ${{ needs.setup.outputs.boltthreads }}
    steps:
      - name: Checkout kernel source (Build Final 1)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Download kernel configuration
        uses: actions/download-artifact@v4
        with:
          name: kernel-config
          path: kernel-src/

      - name: Download baseline artifacts
        uses: actions/download-artifact@v4
        with:
          name: vmlinux-build1
          path: kernel-src/

      - uses: actions/download-artifact@v4
        with:
          name: profdata
          path: kernel-src/profdata

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-

      - name: Final incremental build with PGO round 1 + BOLT + AutoFDO
        working-directory: kernel-src
        run: |
          PROFILE=profdata/kernel.profdata
          if [ -f "$PROFILE" ]; then
            export CFLAGS_KERNEL="-flto=thin -fprofile-use=$PROFILE"
            export LDFLAGS_vmlinux="-flto -fuse-ld=lld -fprofile-use=$PROFILE"
          fi
          make olddefconfig
          # Compilamos bzImage de nuevo con las optimizaciones PGO
          make -j$PARALLEL vmlinux bzImage modules | tee final_auto.log
          
          cat profdata/perf*.out 2>/dev/null > profdata/perf_all.out || true
          if [ -s profdata/perf_all.out ]; then
              llvm-bolt-19 vmlinux -o vmlinux.bolt \
                -reorder-blocks=ext-tsp \
                -reorder-functions=hfsort \
                -split-functions \
                -icf=1 \
                -dyno-trace=profdata/perf_all.out \
                -threads=$BOLTTHREADS | tee bolt.log
              if [ -f vmlinux.bolt ] && [ -s vmlinux.bolt ]; then
                mv vmlinux.bolt vmlinux
                # NOTA: BOLT invalida bzImage porque cambia vmlinux.
                # Para la ronda 2 de PGO, lo ideal es usar vmlinux.bolt.
                # Sin embargo, bzImage no se actualiza mágicamente con BOLT.
                # Para mantener esto simple, usaremos el bzImage PGO (sin bolt) para el arranque de QEMU
                # pero el vmlinux (con bolt) para la recolección de perf.
              fi
          fi

      # AÑADIDO: Subir los artefactos intermedios para la ronda 2
      - name: Upload vmlinux round 1
        uses: actions/upload-artifact@v4
        with:
          name: vmlinux-build2
          path: |
            kernel-src/vmlinux
            kernel-src/arch/x86/boot/bzImage

# ------------------------------
# 4) Segundo round de PGO + AutoFDO
# ------------------------------
  pgo-auto-2:
    needs: build-final-auto
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      MAXQEMU: ${{ needs.setup.outputs.maxqemu }}
    steps:
      - name: Checkout kernel source (PGO 2)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Download kernel configuration
        uses: actions/download-artifact@v4
        with:
          name: kernel-config
          path: kernel-src/

      # Descargar artefactos del Job 3 (Build Final 1)
      - name: Download previous vmlinux
        uses: actions/download-artifact@v4
        with:
          name: vmlinux-build2
          path: kernel-src/
      
      - name: Restore bzImage location
        working-directory: kernel-src
        run: |
            mkdir -p arch/x86/boot
            find . -name bzImage -exec cp {} arch/x86/boot/bzImage \;

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-

      - name: Collect PGO profiles (round 2)
        working-directory: kernel-src
        run: |
          mkdir -p profdata2
          for i in $(seq 1 $MAXQEMU); do
            (
              echo "QEMU instance $i (round 2)"
              dd if=/dev/zero of=disk2_$i.img bs=1M count=256
              mkfs.ext4 disk2_$i.img
              sudo perf record -o profdata2/perf$i.data -e cycles:u \
                qemu-system-x86_64 -kernel arch/x86/boot/bzImage \
                -append "console=ttyS0" -drive file=disk2_$i.img,format=raw \
                -nographic -m 1024M -monitor none &
              QEMU_PID=$!
              sleep 10
              sudo kill $QEMU_PID || true
              perf script > profdata2/perf$i.out || true
              rm -f disk2_$i.img
            ) &
          done
          wait
          if compgen -G "profdata2/*.profraw" > /dev/null; then
            llvm-profdata-19 merge -o profdata2/kernel.profdata profdata2/*.profraw
          fi
      - name: Upload profdata2
        uses: actions/upload-artifact@v4
        with:
          name: profdata2
          path: kernel-src/profdata2

# ------------------------------
# 5) Build final incremental definitivo y release
# ------------------------------
  build-final-auto-2:
    needs:
      - build-final-auto
      - pgo-auto-2
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      BOLTTHREADS: ${{ needs.setup.outputs.boltthreads }}
      XZTHREADS: ${{ needs.setup.outputs.xzthreads }}
    steps:
      - name: Checkout kernel source (Final Release)
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      - name: Download kernel configuration
        uses: actions/download-artifact@v4
        with:
          name: kernel-config
          path: kernel-src/

      - name: Download baseline artifacts
        uses: actions/download-artifact@v4
        with:
          name: vmlinux-build1
          path: kernel-src/
      - uses: actions/download-artifact@v4
        with:
          name: profdata2
          path: kernel-src/profdata2

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
          restore-keys: compilercache-${{ runner.os }}-clang19-v19-

      - name: Final incremental build with PGO round 2 + BOLT + AutoFDO
        working-directory: kernel-src
        run: |
          PROFILE=profdata2/kernel.profdata
          if [ -f "$PROFILE" ]; then
            export CFLAGS_KERNEL="-flto=thin -fprofile-use=$PROFILE"
            export LDFLAGS_vmlinux="-flto -fuse-ld=lld -fprofile-use=$PROFILE"
          fi
          make olddefconfig
          # Compilamos vmlinux y modulos antes de empaquetar
          make -j$PARALLEL vmlinux modules | tee finalautoround2.log
          
          # Aplicar BOLT
          cat profdata2/perf*.out 2>/dev/null > profdata2/perf_all.out || true
          if [ -s profdata2/perf_all.out ]; then
              llvm-bolt-19 vmlinux -o vmlinux.bolt \
                -reorder-blocks=ext-tsp \
                -reorder-functions=hfsort \
                -split-functions \
                -icf=1 \
                -dyno-trace=profdata2/perf_all.out \
                -threads=$BOLTTHREADS | tee boltround2.log
              if [ -f vmlinux.bolt ] && [ -s vmlinux.bolt ]; then
                mv vmlinux.bolt vmlinux
              fi
          fi
          # IMPORTANTE: NO comprimimos vmlinux aquí (sin xz) porque bindeb-pkg lo necesita descomprimido.

      - name: Build .deb packages + SHA256
        working-directory: kernel-src
        run: |
          export DEBBUILDOPTIONS="parallel=$PARALLEL"
          rm -rf ../debs2
          mkdir -p ../debs2
          
          # Generamos los paquetes. bindeb-pkg usará el vmlinux existente (que ya tiene BOLT)
          # a menos que detecte cambios masivos.
          make -j$PARALLEL bindeb-pkg LOCALVERSION="-${{ github.run_number }}-final" | tee debround2.log
          
          cp ../*.deb ../debs2/
          cd ../debs2
          sha256sum *.deb > SHA256SUMS.txt

      - name: Generate CHANGELOG
        working-directory: kernel-src
        run: |
          PREV=$(git describe --tags --abbrev=0 --match "v*" HEAD^ 2>/dev/null || true)
          if [ -n "$PREV" ]; then
            git log --pretty=format:"%h - %s (%an)" "$PREV"..HEAD > ../CHANGELOG.txt
          else
            git log --reverse --max-count=30 --pretty=format:"%h - %s (%an)" > ../CHANGELOG.txt
          fi

      - name: Upload final release artifacts
        uses: softprops/action-gh-release@v1
        with:
          files: |
            debs2/*.deb
            debs2/SHA256SUMS.txt
            ../CHANGELOG.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

