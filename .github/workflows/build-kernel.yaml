name: Kernel Debian-Compatible (PGO + BOLT + AutoFDO Incremental, Ultra-Fast, OOM-safe)

# ------------------------------
# Activadores del workflow
# ------------------------------
on:
  push:
    tags:
      - 'v*'           # Ejecuta el workflow al hacer push de tags que comiencen con "v"
  workflow_dispatch:    # Permite ejecución manual desde GitHub Actions

# ------------------------------
# Variables de entorno globales
# ------------------------------
env:
  CCACHE_DIR: ${{ github.workspace }}/.ccache
  SCCACHE_DIR: ${{ github.workspace }}/.sccache

jobs:
  # ------------------------------
  # 0) Configuración inicial del runner
  # ------------------------------
  setup:
    runs-on: ubuntu-latest
    outputs:
      parallel: ${{ steps.calc-parallel.outputs.parallel }}
      max_qemu: ${{ steps.calc-parallel.outputs.max_qemu }}
      bolt_threads: ${{ steps.calc-parallel.outputs.bolt_threads }}
      xz_threads: ${{ steps.calc-parallel.outputs.xz_threads }}
    steps:
      # Clonar el repositorio del kernel
      - name: Checkout kernel source
        uses: actions/checkout@v4
        with:
          repository: CypherNoodle/linux-Sw1-011
          path: kernel-src
          fetch-depth: 0
          persist-credentials: false

      # Instalar dependencias necesarias (LLVM/Clang, build tools, QEMU, perf, utilidades)
      - name: Install dependencies
        run: |
          set -euo pipefail
          wget https://apt.llvm.org/llvm.sh
          chmod +x llvm.sh
          sudo ./llvm.sh 19                          # Instalar LLVM/Clang 19
          sudo apt update
          sudo apt install -y build-essential bc bison flex libssl-dev libelf-dev libdw-dev \
          libncurses-dev libncurses5-dev fakeroot dpkg-dev debhelper dwarves zstd git \
          qemu-system-x86 qemu-kvm ccache sccache linux-tools-common linux-tools-generic \
          linux-tools-$(uname -r) zlib1g-dev xz-utils
          mkdir -p $CCACHE_DIR $SCCACHE_DIR profdata profdata2

      # Configurar swap dinámico si la RAM disponible < 4GB
      - name: Setup dynamic swap
        id: swap
        run: |
          MEM_AVAIL=$(free -m | awk '/^Mem:/ {print $7}')
          SWAPFILE=/swapfile
          if [ "$MEM_AVAIL" -lt 4000 ]; then
              echo "Menos de 4GB de RAM detectada, creando swap de 4GB..."
              SWAP_SIZE=4096
              sudo fallocate -l ${SWAP_SIZE}M $SWAPFILE
              sudo chmod 600 $SWAPFILE
              sudo mkswap $SWAPFILE
              sudo swapon $SWAPFILE
              echo "swapfile=$SWAPFILE" >> $GITHUB_OUTPUT
          else
              echo "swapfile=none" >> $GITHUB_OUTPUT
          fi

      # Calcular paralelismo seguro basado en RAM disponible para make, QEMU, BOLT y XZ
      - name: Calculate safe parallelism & threads
        id: calc-parallel
        run: |
          MEM=$(free -m | awk '/^Mem:/ {print $2}')
          PARALLEL=$(( MEM / 1500 ))
          PARALLEL=$(( PARALLEL < 1 ? 1 : PARALLEL ))
          MAX_QEMU=$(( MEM / 1024 ))
          MAX_QEMU=$(( MAX_QEMU < 1 ? 1 : MAX_QEMU ))
          MAX_QEMU=$(( MAX_QEMU > 4 ? 4 : MAX_QEMU )) # Limitar a 4 QEMU
          BOLT_THREADS=$(( PARALLEL / 2 ))
          BOLT_THREADS=$(( BOLT_THREADS < 1 ? 1 : BOLT_THREADS ))
          XZ_THREADS=$(( PARALLEL / 2 ))
          XZ_THREADS=$(( XZ_THREADS < 1 ? 1 : XZ_THREADS ))
          echo "parallel=$PARALLEL" >> $GITHUB_OUTPUT
          echo "max_qemu=$MAX_QEMU" >> $GITHUB_OUTPUT
          echo "bolt_threads=$BOLT_THREADS" >> $GITHUB_OUTPUT
          echo "xz_threads=$XZ_THREADS" >> $GITHUB_OUTPUT

      # Restaurar cache de compilador (ccache y sccache)
      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}

  # ------------------------------
  # 1) Build incremental base
  # ------------------------------
  build-incremental:
    needs: setup
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
    steps:
      # Configuración inicial del kernel si no existe .config
      - name: Kernel configuration
        working-directory: kernel-src
        run: |
          set -euo pipefail
          if [ ! -f .config ]; then
            make defconfig
            echo "CONFIG_LTO_CLANG=y" >> .config
            echo "CONFIG_THINLTO=y" >> .config
            make olddefconfig
          fi

      # Compilación incremental del kernel y módulos
      - name: Incremental compile baseline kernel
        working-directory: kernel-src
        run: |
          set -euo pipefail
          export CC="sccache clang-19"
          export HOSTCC="ccache clang-19"
          export HOSTCXX="ccache clang++-19"
          export LD=lld
          make -j$PARALLEL vmlinux modules | tee baseline_incremental.log

      # Subir vmlinux generado como artefacto
      - name: Upload vmlinux baseline
        uses: actions/upload-artifact@v4
        with:
          name: vmlinux
          path: kernel-src/vmlinux

  # ------------------------------
  # 2) Primer round de PGO + AutoFDO
  # ------------------------------
  pgo-auto:
    needs: build-incremental
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      MAX_QEMU: ${{ needs.setup.outputs.max_qemu }}
    steps:
      - name: Download baseline vmlinux
        uses: actions/download-artifact@v4
        with:
          name: vmlinux
          path: kernel-src/

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}

      # Recolectar perfiles usando QEMU y perf (round 1)
      - name: Collect PGO profiles (round 1)
        working-directory: kernel-src
        run: |
          mkdir -p profdata
          for i in $(seq 1 $MAX_QEMU); do
            (
              echo "QEMU instance $i (round 1)"
              dd if=/dev/zero of=disk$i.img bs=1M count=256
              mkfs.ext4 disk$i.img
              sudo perf record -o profdata/perf$i.data -e cycles:u \
                qemu-system-x86_64 -kernel arch/x86/boot/bzImage \
                -append "console=ttyS0" -drive file=disk$i.img,format=raw \
                -nographic -m 1024M -monitor none &
              QEMU_PID=$!
              sleep 10
              sudo kill $QEMU_PID || true
              perf script > profdata/perf$i.out || true
              rm -f disk$i.img
            ) &
          done
          wait
          if compgen -G "profdata/*.profraw" > /dev/null; then
            llvm-profdata-19 merge -o profdata/kernel.profdata profdata/*.profraw
          fi

      - name: Upload profdata
        uses: actions/upload-artifact@v4
        with:
          name: profdata
          path: kernel-src/profdata

  # ------------------------------
  # 3) Build final con PGO round 1 + BOLT + AutoFDO
  # ------------------------------
  build-final-auto:
    needs:
      - build-incremental
      - pgo-auto
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      BOLT_THREADS: ${{ needs.setup.outputs.bolt_threads }}
      XZ_THREADS: ${{ needs.setup.outputs.xz_threads }}
    steps:
      - name: Download baseline artifacts
        uses: actions/download-artifact@v4
        with:
          name: vmlinux
          path: kernel-src/
      - uses: actions/download-artifact@v4
        with:
          name: profdata
          path: kernel-src/profdata

      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}

      # Compilación final con PGO round 1 + BOLT + AutoFDO
      - name: Final incremental build with PGO round 1 + BOLT + AutoFDO
        working-directory: kernel-src
        run: |
          PROFILE=profdata/kernel.profdata
          if [ -f "$PROFILE" ]; then
            export CFLAGS_KERNEL="-flto=thin -fprofile-use=$PROFILE"
            export LDFLAGS_vmlinux="-flto -fuse-ld=lld -fprofile-use=$PROFILE"
          fi
          make -j$PARALLEL vmlinux modules | tee final_auto.log
          cat profdata/perf*.out 2>/dev/null > profdata/perf_all.out || true
          if [ -s profdata/perf_all.out ]; then
              llvm-bolt-19 vmlinux -o vmlinux.bolt \
                -reorder-blocks=ext-tsp \
                -reorder-functions=hfsort \
                -split-functions \
                -icf=1 \
                -dyno-trace=profdata/perf_all.out \
                -threads=$BOLT_THREADS | tee bolt.log
              if [ -f vmlinux.bolt ] && [ -s vmlinux.bolt ]; then
                mv vmlinux.bolt vmlinux
              fi
          fi
          xz -T$XZ_THREADS -9 vmlinux

  # ------------------------------
  # 4) Segundo round de PGO + AutoFDO
  # ------------------------------
  pgo-auto-2:
    needs: build-final-auto
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      MAX_QEMU: ${{ needs.setup.outputs.max_qemu }}
    steps:
      - name: Download previous vmlinux
        uses: actions/download-artifact@v4
        with:
          name: vmlinux
          path: kernel-src/
      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}
      - name: Collect PGO profiles (round 2)
        working-directory: kernel-src
        run: |
          mkdir -p profdata2
          for i in $(seq 1 $MAX_QEMU); do
            (
              echo "QEMU instance $i (round 2)"
              dd if=/dev/zero of=disk2_$i.img bs=1M count=256
              mkfs.ext4 disk2_$i.img
              sudo perf record -o profdata2/perf$i.data -e cycles:u \
                qemu-system-x86_64 -kernel arch/x86/boot/bzImage \
                -append "console=ttyS0" -drive file=disk2_$i.img,format=raw \
                -nographic -m 1024M -monitor none &
              QEMU_PID=$!
              sleep 10
              sudo kill $QEMU_PID || true
              perf script > profdata2/perf$i.out || true
              rm -f disk2_$i.img
            ) &
          done
          wait
          if compgen -G "profdata2/*.profraw" > /dev/null; then
            llvm-profdata-19 merge -o profdata2/kernel.profdata profdata2/*.profraw
          fi
      - name: Upload profdata2
        uses: actions/upload-artifact@v4
        with:
          name: profdata2
          path: kernel-src/profdata2

  # ------------------------------
  # 5) Build final incremental definitivo y release
  # ------------------------------
  build-final-auto-2:
    needs:
      - build-final-auto
      - pgo-auto-2
    runs-on: ubuntu-latest
    env:
      PARALLEL: ${{ needs.setup.outputs.parallel }}
      BOLT_THREADS: ${{ needs.setup.outputs.bolt_threads }}
      XZ_THREADS: ${{ needs.setup.outputs.xz_threads }}
    steps:
      - name: Download baseline artifacts
        uses: actions/download-artifact@v4
        with:
          name: vmlinux
          path: kernel-src/
      - uses: actions/download-artifact@v4
        with:
          name: profdata2
          path: kernel-src/profdata2
      - name: Restore compiler caches
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/.ccache
            ${{ github.workspace }}/.sccache
          key: compilercache-${{ runner.os }}-clang19-v19-${{ hashFiles('kernel-src/.config') }}

      # Compilación final con PGO round 2 + BOLT + AutoFDO
      - name: Final incremental build with PGO round 2 + BOLT + AutoFDO
        working-directory: kernel-src
        run: |
          PROFILE=profdata2/kernel.profdata
          if [ -f "$PROFILE" ]; then
            export CFLAGS_KERNEL="-flto=thin -fprofile-use=$PROFILE"
            export LDFLAGS_vmlinux="-flto -fuse-ld=lld -fprofile-use=$PROFILE"
          fi
          make -j$PARALLEL vmlinux modules | tee final_auto_round2.log
          cat profdata2/perf*.out 2>/dev/null > profdata2/perf_all.out || true
          if [ -s profdata2/perf_all.out ]; then
              llvm-bolt-19 vmlinux -o vmlinux.bolt \
                -reorder-blocks=ext-tsp \
                -reorder-functions=hfsort \
                -split-functions \
                -icf=1 \
                -dyno-trace=profdata2/perf_all.out \
                -threads=$BOLT_THREADS | tee bolt_round2.log
              if [ -f vmlinux.bolt ] && [ -s vmlinux.bolt ]; then
                mv vmlinux.bolt vmlinux
              fi
          fi
          xz -T$XZ_THREADS -9 vmlinux

      # Construir paquetes .deb y SHA256
      - name: Build .deb packages + SHA256
        working-directory: kernel-src
        run: |
          export DEB_BUILD_OPTIONS="parallel=$PARALLEL"
          rm -rf ../debs2
          mkdir -p ../debs2
          make -j$PARALLEL bindeb-pkg LOCALVERSION="-${{ github.run_number }}-final" | tee deb_round2.log
          cp ../*.deb ../debs2/
          cd ../debs2
          sha256sum *.deb > SHA256SUMS.txt

      # Generar CHANGELOG final único
      - name: Generate CHANGELOG
        working-directory: kernel-src
        run: |
          PREV=$(git describe --tags --abbrev=0 --match "v*" HEAD^ 2>/dev/null || true)
          if [ -n "$PREV" ]; then
            git log --pretty=format:"%h - %s (%an)" "$PREV"..HEAD > ../CHANGELOG.txt
          else
            git log --reverse --max-count=30 --pretty=format:"%h - %s (%an)" > ../CHANGELOG.txt

      # Subir artefactos finales al release
      - name: Upload final release artifacts
        uses: softprops/action-gh-release@v1
        with:
          files: |
            debs2/*.deb
            debs2/SHA256SUMS.txt
            ../CHANGELOG.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
